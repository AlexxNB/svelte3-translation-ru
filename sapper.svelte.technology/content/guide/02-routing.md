---
title: Маршруты
---
Как мы уже видели, в Sapper есть два типа маршрутов - маршруты страницы и маршруты сервера.


### Страницы

Страницы - это компоненты Svelte, описанные в файлах `.html`. Когда пользователь впервые посещает приложение, ему будет предоставлена сгенерирования на сервере версия запрошенного маршрута, а также некоторый JavaScript, который выполняет 'гидратацию' страницы и инициализирует маршрутизатор на стороне клиента. С этого момента навигация на другие страницы будет полностью выполняется на стороне клиента обеспечивая очень быстрое пермещение, что типично для клиентских приложений.

Имя файла определяет маршрут. Например, `src/routes/index.html` - корневой файл вашего сайта:

```html
<!-- src/routes/index.html -->
<svelte:head>
	<title>Добро пожаловать!</title>
</svelte:head>

<h1>Приветствую вас на моем сайте!</h1>
```

Файл с именем `src/routes/about.html` или `src/routes/about/index.html` будет соответствовать маршруту `/about`:

```html
<!-- src/routes/about.html -->
<svelte:head>
	<title>О сайте</title>
</svelte:head>

<h1>Информация о сайте</h1>
<p>Это самый лучший сайт!</p>
```

Динамические параметры задаются при помощи квадратных скобок `[...]`. Например, таким образом можно сделать страницу, отображающую статью из блога:

```html
<!-- src/routes/blog/[slug].html -->
<svelte:head>
	<title>{article.title}</title>
</svelte:head>

<h1>{article.title}</h1>

<div class='content'>
	{@html article.html}
</div>

<script>
	export default {
		// необязательная функция preload принимает объект
		// `{ params, query }` и превращает его в
		// данные, которые надо отрисовать на странице
		preload({ params, query }) {
			// у нас есть доступ к параметру `slug`, потому что
			// файл называется [slug].html
			const { slug } = params;

			return this.fetch(`blog/${slug}.json`).then(r => r.json()).then(article => {
				return { article };
			});
		}
	};
</script>
```

> Подробнее о функциях `preload` и `this.fetch`  мы узнаем в разделе [Предзагрузка](guide#preloading) 

### Маршруты сервера

Серверные маршруты - это модули, написанные в файлах `.js`, которые экспортируют функции, соответствующие HTTP методам. Каждая функция получает в качестве аргументов объекты HTTP `request` и `response`, а также функцию `next`. Это полезно для создания JSON API. Например, вот как бы вы могли бы создать эндпоинт, который бы обслуживал страницу блога выше:

```js
// routes/blog/[slug].json.js
import db from './_database.js'; // нижнее подчеркивание, говорит Sapper, что это не маршрут
export async function get(req, res, next) {
	// у нас есть доступ к параметру `slug`, потому что
	// файл называется [slug].json.js
	const { slug } = req.params;

	const article = await db.get(slug);

	if (article !== null) {
		res.setHeader('Content-Type', 'application/json');
		res.end(JSON.stringify(article));
	} else {
		next();
	}
}
```

> `delete` - зарезервированное слово в JavaScript. Для обработки запросов DELETE экспортируйте функцию с именем `del`.


### Правила именования файлов

Существует три простых правила именования файлов, которые определяют ваши маршруты:

* Файл с именем `src/routes/about.html` соответствует маршруту `/about`. Файл с именем `src/routes/blog/[slug].html` соответствует маршруту `/blog/:slug`, и в этом случае `params.slug` доступен для `preload`
* Файл `src/routes/index.html` соответствует корню вашего сайта. `src/routes/about/index.html` обрабатывается так же, как `src/routes/about.html`.
* Файлы и каталоги начинающиеся с нижнего подчеркивания *не* создают маршруты. Это позволяет объединять вспомогательные модули и компоненты с маршрутами, которые зависят от них - например, у вас может быть файл с именем `src/routes/_helpers/datetime.js`, но маршрут `/_helpers/datetime` *не* будет создан



### Страница с ошибкой

В дополнение к обычным страницам есть специальная страница, которую Sapper ожидает найти по пути - `src/routes/_error.html`. Она будет показана, если возникнет ошибка при отображении запрошенной страницы.

В шаблоне будет доступен объект `error` и код HTTP статуса в `status`.



### Регулярные выражения в маршрутах

Вы можете использовать регулярные выражения для указания параметров маршрута, поместив их в скобки после имени параметра.

Например, `src/routes/items/[id([0-9]+)].html` будет соответствовать только числовым идентификаторам — `/items/123`, а маршрут `/items/xyz` не пройдет.

Из-за технических особенностей, в регулярных выражениях невозможно использовать следующие символы: `/`, `\`, `?`, `:`, `(` and `)`.
