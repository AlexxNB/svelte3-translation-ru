---
title: Управление состоянием
---

Sapper интегрируется со встроенным хранилищем Svelte. Если вы ещё не познакомились с ним, то сначала настоятельно рекомендуем прочитать в руководстве по Svelte раздел [Управление состоянием](https://svelte.technology/guide#state-management).

Чтобы использовать хранилище, вы должны по отдельности интегрировать его в ваши серверное и клиентское приложение.

### Сервер

В отличие от клиентского приложения, где постоянно имеется лишь один экземпляр хранилища, который работает, пока открыта страница, приложение на стороне сервера должно каждый раз создавать новый объект Store для каждого запроса:

```js
// app/server.js
import { Store } from 'svelte/store.js';

express() // или Polka, или подобный фреймворк
	.use(
		compression({ threshold: 0 }),
		serve('assets'),
		authenticationMiddleware(),
		sapper.middleware({
			store: request => {
				return new Store({
					user: request.user
				});
			}
		})
	)
	.listen(process.env.PORT);
```

В этом примере мы используем некую воображаемую функцию `authenticationMiddleware`, которая создаёт объект `request.user` на основе файлов cookie пользователя. (В реальной жизни это, обычно, немного сложнее - см. [Express-session](https://github.com/expressjs/session) или [Passport](http://www.passportjs.org/), если вы хотите почитать больше о сессиях и аутентификации.)

Поскольку мы указали опцию `store`, Sapper будет создавать новый экземпляр объекта `Store` для каждого нового запроса `request`. Данные в нашем хранилище будут использоваться для визуализации HTML-кода, который вернёт Sapper.


### Клиент

На клиентской стороне мы создаём отдельное хранилище, которое доступно постоянно, даже когда пользователь переходит между страницами приложения.

```js
import * as sapper from '../__sapper__/client.js';
import { Store } from 'svelte/store.js';

sapper.start({
	target: document.querySelector('#sapper'),
	store: data => {
		// `data` это то, что было в хранилище на стороне сервера
		return new Store(data);
	}
});
```

>Для повторного использования данных в хранилище на сервере, они должны быть сериализуемыми (для сериализации мы используем [devalue](https://github.com/Rich-Harris/devalue)) - т.е. не должно быть никаких функций или пользовательских классов, могут быть только встроенные типы данных JavaScript
