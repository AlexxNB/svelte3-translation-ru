---
title: Изолированые стили
---

Одним из ключевых принципов Svelte является то, что компоненты должны быть автономными и многократно использоваться в разных контекстах. Поэтому у него есть механизм *ограничения области видимости* CSS стилей компонента, который не позволит случайно перезаписать другие селекторы на странице.


### Добавление стилей

Шаблон компонента может содержать тег `<style>`. Например вот так:

```html
<!--{ title: 'Scoped styles' }-->
<style>
	.foo {
		color: red;
		font-size: 2em;
		font-family: 'Comic Sans MS';
	}
</style>

<div class="foo">
	Большой и красный Comic Sans
</div>
```


### Как это работает?

Откройте приведенный выше пример в REPL и исследйте элемент в инструментах разработчика, чтобы увидеть, что произошло - Svelte добавил к элементу класс `svelte-[уникальный_ключ]` и соответствующим образом изменил селектор CSS. Поэтому, если вдруг где-то на странице еще встретится элемент с `class="foo"`, то он не будет затронут стилями из компонента.

Такой подход значительно проще, чем достижение аналогичного эффекта с использованием технологии [Shadow DOM](http://caniuse.com/#search=shadow%20dom) и при этом работает без каких-либо полифилов.

> Svelte добавляет тег `<style>` на страницу, содержащую ваши изолированые стили. Динамическое добавление стилей может быть запрещено, если на вашем сайте настроена [политика защиты контента - CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP). В этом слчае вы можете использовать [серверный рендеринг CSS](guide#rendering-css) указав опцию компилятора `css: false` (или`--no-css` для CLI).


### Каскадирование стилей 

Стили применятся *только* к текущему компоненту, если только вы 

Styles will *only* apply to the current component, если вы не включите каскадирование модификатором`:global(...)`:

<!-- TODO `cascade: false` in the REPL -->

```html
<!-- { repl: false } -->
<script>
	import Widget from './Widget.html';
</script>

<style>
	p {
		/* этот блок будет проигнорирован, так как в компоненте нет элемента <p>*/
		color: red;
	}

	div :global(p) {
		/* этот блок будет применен ко всем элементам <p> внутри элемента <div>, в том числе и внутри компонента <Widget> */
		font-weight: bold;
	}
</style>

<div>
	<Widget/>
</div>
```

> Изолированые стили *не являются* динамическими и используются всеми экземплярами компонента. Другими словами, вы не сможете использовать  `{теги}` внутри CSS стилей.
> 

### Удаление неиспользуемых стилей

При сборке Svelte определит и удалит стили, которые не используются в вашем приложении. При этом будет показано предупреждение, чтобы вы могли удалить их из источника.

Чтобы правила *не были* удалены, они должны применяться к разметке компонента. В примере ниже, класс `.bold` не используется в коде и должен быть удален:

```html
<!-- { repl: false } -->
<div>
	<p bind:this={paragraph}>этот текст не жирный</p>
</div>

<style>
	.bold {
		color: bold;
	}
</style>

<script>
	import { onMount } from 'svelte';

	let paragraph;
	onMount(() => {
		paragraph.classList.add('bold');
	});
</script>
```

Вместо ручного манипулирования свойствами элементов DOM, необходимо использовать  атрибут `class`  (или [директиву class](https://svelte.technology/guide#classes)):


```html
<!-- { repl: false } -->
<div>
	<p class:bold={bold}>этот текст жирный</p>
</div>
```

Если это по каким-то причинам невозможно, используйте `:global(...)`:

```html
<!-- { repl: false } -->
<style>
	div :global(.bold) {
		color: bold;
	}
</style>
```

То же самое относится и к содержимому тегов `{@html ...}`.