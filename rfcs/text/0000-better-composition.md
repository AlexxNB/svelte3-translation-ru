- Start Date: 2019-01-19
- RFC PR: [#12](https://github.com/sveltejs/rfcs/pull/12)
- Svelte Issue: (leave this empty)

# Улучшение компоновки

## Резюме

Компоненты Svelte 3 можно комбинировать различными способами для выполнения практически любых задач. Но иногда встречаются довольно сложные задачи и их решение получается с излишне перегруженным кодом. В этом RFC предлагается ряд изменений в использовании `<slot>`  для обеспечения более идиоматических и мощных шаблонов компоновки компонентов.

## Мотивация

### Неконтролируемые компоненты

Нам нужнна возможность делать вещи, вроде этой... (взято от сюда: https://github.com/reactjs/react-tabs)...

```html
<Tabs>
  <TabList>
    <Tab>Заголовок 1</Tab>
    <Tab>Заголовок 2</Tab>
  </TabList>

  <TabPanel>
    <h2>Какой-то контент 1</h2>
  </TabPanel>
  <TabPanel>
    <h2>Какой-то контент 2</h2>
  </TabPanel>
</Tabs>
```

...или этой...

```html
<Tabs>
  <Tab title="Заголовок 1">
    <h2>Какой-то контент 1</h2>
  </Tab>

  <Tab title="Заголовок 2">
    <h2>Какой-то контент 2</h2>
  </Tab>
</Tabs>
```

...или любой другой подобной кофигурации. При клике на компонент `<Tab>` нужно сделать соответствующий контент видимым. В идеале невидимые вкладки не должны рендериться — другими словами, в любой момент времени должен существовать только один элемент `<h2>`. В настоящее время Svelte рендерит контент со слотами *скрыто*, подобно Light DOM в web-компонентах.

Подобным образом, мы бы могли скомпоновать такой график...

```html
{#each anscombesQuartet as points}
  <Chart {points}>
    <XAXis ticks labels/>
    <YAXis ticks/>
    <Scatterplot/>
    <VoronoiOverlay on:highlight={highlight}/>
  </Chart>
{/each}
```

...в котором компоненты оси и точек (и любые другие — хоть, `<Annotation>`) используют масштаб и данные, предоставленные компонентом `<Chart>`.

Всё это подразумевает прозрачное взаимодейтсвие между компонентами — что в настоящее время в Svelte невозможно. Поэтому нужен другой подход к передаче контента в `<slot>` компонентов.

### Контекст слотов и итерация

Ещё одна встречающаяся проблема: слоты можно использовать только единожды. Например, вы не можете использовать содержимое слота для создания пунктов в списке [svelte-virtual-list](https://github.com/sveltejs/svelte-virtual-list), хотя это сильно удобнее, чем передавать объект в компонент в качестве свойства.


#### Текущий подход

```html
<script>
  import VirtualList from '@sveltejs/svelte-virtual-list';
  import RowComponent from './RowComponent.html';

  const things = [
    { name: 'one', number: 1 },
    { name: 'two', number: 2 },
    { name: 'three', number: 3 },
    // ...
    { name: 'six thousand and ninety-two', number: 6092 }
  ];
</script>

<VirtualList items={things} component={RowComponent} />
```

```html
<!-- RowComponent.html -->
<div>
  <strong>{number}</strong>
  <span>{name}</span>
</div>
```


#### Что можно улучшить?

```html
<script>
  import VirtualList from '@sveltejs/svelte-virtual-list';

  const things = [
    // это могут быть какие угодно значения
    { name: 'one', number: 1 },
    { name: 'two', number: 2 },
    { name: 'three', number: 3 },
    // ...
    { name: 'six thousand and ninety-two', number: 6092 }
  ];
</script>

<VirtualList items={things}>
  <div>
    <!-- тут идёт разметка -->
  </div>
</VirtualList>
```


## Детальный дизайн

### 'Ленивый' рендеринг

Для большей части того, что было описано выше, требуется, чтобы жизненный цикл контента в слоте управлялся из дочернего компонента, а не из родительского. В текущем подходе все содержимое слота ренедрится родительким компонентом и передаётся в дочерний, примерно как light DOM передаётся пользовательским элементам.

Пример кода я добавлю позже, как только приведу мозги в порядок.


### Неуправляемый контекст компонента

Чтобы реализовать работать следующий паттерн...

```html
<Tabs>
  <TabList>
    <Tab>Заголовок 1</Tab>
    <Tab>Заголовок 2</Tab>
  </TabList>

  <TabPanel>
    <h2>Какой-то контент 1</h2>
  </TabPanel>
  <TabPanel>
    <h2>Какой-то контент 2</h2>
  </TabPanel>
</Tabs>
```

...каждый компонент `<Tab>` должен иметь возможность сообщить в `<Tabs>` (возможно, через `<TabList>`, в зависимости от того, как задуман компонент), что он был выбран пользователем. Он также должен знать свой порядковый индекс относительно других `<Tab>` рядом, даже если он был создан после первоначального рендеринга или ранее какая-либо вкладка была удалена из списка.

Аналогично, каждая `<TabPanel>` должна знать свой собственный индекс (который тоже может изменяться по ходу пьесы) и текущий индекс текущей выбранной вкладки. Если панель *выбрана*, она должна рендерить своё дочернее содержимое, в ином случае отрисовки быть не должно.

Возможно, это может выглядеть примерно так:

```html
<!-- Tabs.html -->
<script context="module">
  export const TABS = {};
</script>

<script>
  import { setContext } from 'svelte';
  import { writable } from 'svelte/store';

  const tabs = [];
  const panels = [];
  const selected = writable(null);

  setContext(TABS, {
    registerTab: tab => {
      tabs.push(tab);
    },

    unregisterTab: tab => {
      const i = tabs.indexOf(tab);
      tabs.splice(i, 1);
    },

    registerPanel: panel => {
      panels.push(panel);

      // если это первая панель, выбираем её
      selected.update(current => current || panel);
    },

    unregisterPanel: panel => {
      const i = panels.indexOf(panel);
      panels.splice(i, 1);
    },

    selectTab: tab => {
      const i = tabs.indexOf(tab);
      selected.set(panels[i]);
    },

    selected
  });
</script>

<div class="tabs">
  <slot></slot>
</div>
```

```html
<!-- Tab.html -->
<script>
  import { getContext, onDestroy } from 'svelte';
  import { TABS } from './Tabs.html';

  const tab = {};
  const { registerTab, unregisterTab, selectTab } = getContext(TABS);

  registerTab(tab);

  onDestroy(() => {
    unregisterTab(tab);
  });
</script>

<button on:click="{() => selectTab(tab)}">
  <slot></slot>
</button>
```

```html
<!-- TabPanel.html -->
<script>
  import { getContext, onDestroy } from 'svelte';
  import { TABS } from './Tabs.html';

  const panel = {};
  const { registerPanel, unregisterPanel, selected } = getContext(TABS);
  registerPanel(panel);

  onDestroy(() => {
    unregisterPanel(panel);
  });
</script>

{#if $selected === panel}
  <slot></slot>
{/if}
```

> Это только первый набросок - но я хочу тут показать пару вещей

Здесь `setContext` и `getContext` - это функции, которые должны вызываться во время инициализации компонента, вроде функций жизненного цикла. `getContext(arg)` извлекает любой контекст, который был задан аргументом `arg` *в родительском компоненте* (который может быть чем угодно, включая строку вроде 'tabs', но использование `{}` гарантирует отсутствие коллизий). Это позволяет любому компоненту иметь несколько экземпляров `<Tabs>` или даже самому компоненту `<Tabs>` иметь вложенные вкладки.

> TODO кружок есть, надо дорисовать сову

### Явная область видимости слота

Приведённый выше пример работает в *неявном* контексте, то есть слот шарится между компонентами без какого-либо вмешательства автора приложения. Иногда нам нужен *явный* контекст или иными словами 'изолированная' область видимости, например, в примере с `<VirtualList>`.

React может добиться этого с помощью шаблона переданного в свойстве:

```html
<VirtualList items={things}>{({ number, name }) =>
  <div>
    <strong>{number}</strong>
    <span>{name}</span>
  </div>
}</VirtualList>
```

Для нас как-то сложновато. Возможно, мы могли бы достичь того же результата с помощью новой директивы `let`:

```html
<VirtualList items={things} let:item>
  <div>
    <strong>{item.number}</strong>
    <span>{item.name}</span>
  </div>
</VirtualList>
```

Директива `let:item` — это сокращение от `let:item={item}`,она делает `item` доступным для дочернего контента, в принципе так же, как при использовании `{#each items as item}`. Компонент `<VirtualList>` сделает `item` доступным следующим образом:

```html
{#each visible as row (row.index)}
  <div class="row">
    <slot item={row.item}></slot>
  </div>
{/each}
```

Вероятно мы можем сделать и деструктуризацию:

```html
<VirtualList items={things} let:item="{{ name, number }}">
  <div>
    <strong>{number}</strong>
    <span>{name}</span>
  </div>
</VirtualList>
```

Для не дефолтных слотов, директива будет прикрепляться к вложенному в слот элементу:

```html
<div slot="footer" let:year>
  <p>Copyright {year} SvelteJS Inc</p>
</div>
```

С точки зрения сгенерированного кода, дочерний компонент будет дополнять свой собственный контекст любыми свойствами слота:
```js
const slot_scope = Object.assign(component_ctx, {
  item: ctx.item
});
```

> TODO кружок есть, надо дорисовать сову


## Как мы будем этому учить

С точки зрения терминологии, 'неконтролируемый компонент' и 'контекст' - это термины, довольно широко используемые в сообществе React, а 'слоты со своей областью видимости' используется в мире Vue. Имеет смысл использовать один и тот же язык.

Для подавляющего большинства пользователей эти изменения являются чисто аддитивными, не требующими реальной реорганизации существующей документации. Единственное изменение (см. 'Недостатки') состоит в том, что `<slot>` больше не ведёт себя точно так же, как его собственный эквивалент HTML, поскольку теперь мы можем указывать область видимости слота.


## Недостатки

Это сложно реализовать и добавляет сложности. С другой стороны, текущий механизм слотов тоже весьма сложен.

Текущий метод позволяет использовать API слотов программно, передавая объект `slot: { default, named }` при инициализации (где `default` и `named` — это элементы HTML или фрагменты документа). Это больше не будет возможно, т.к. жизненный цикл слотов будет контролирлваться потомком, а не родителем. Лично я никогда не использовал этот API, и я удивлюсь, если его использовало достаточное количество людей, но, тем не менее, это недостаток.

Наконец, это предложение удаляет нас от согласования с веб-компонентами. Компонент Svelte, имеющий `<slot>` внутри каждого блока (например, svelte-virtual-list), не может быть реально скомпилирован в веб-компонент. Впрочем, веб-компоненты в их текущей стадии реализации мало кто вообще использует.

## Альтернативы

Альтернатива — ничего не делать и полагаться на существующие методы композиции. Как мы уже видели, у текущего подхода есть ограничения.

Ещё мы можем задать контекст отдельно от кода. Реакт делает это так:

```js
import { createContext, useContext } from 'react';

const ThemeContext = createContext('light');

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ChildComponent/>
    </ThemeContext.Provider>
  );
}

function ChildComponent() {
  const theme = useContext(ThemeContext);

  return (
    <div className={theme}>
      <p>Current theme is {theme}</p>
    </div>
  );
}
```

Другими словами, контекст может быть создан в любом месте внутри разметки компонента, а не просто в блоке `<script>` при создании экземпляра с помощью `setContext`. Это хорошо работает в теории, но на практике код становится слишком громоздким при использовании более сложных значений (таких как контекст, созданный компонентом `<Tabs>` из примера выше). 'Контекст' в этом RFC - это больше, чем просто значение; это потенциально способ для связанных компонентов общаться друг с другом, устраняя необходимость для компонента манипулировать его дочерними элементами так, как это обычно делают неуправляемые компоненты React.


## Нерешённые вопросы

Все ли термины определены корректно?