- Start Date: 2018-11-01
- RFC PR: https://github.com/sveltejs/rfcs/pull/4
- Svelte Issue: https://github.com/sveltejs/svelte/issues/1826

# Реактивные присваивания

## Резюме

Этот RFC предлагает принципиально новую компановку компонентов, которая решает самые большие проблемы Svelte в его текущем воплощении, и должна способствовать к меньшему размеру приложений и меньшему количеству кода для их записи. Это возможно, благодаря тому что Svelte - это компилятор и решает проблемы *реактивности* на уровне языка.

## Мотивация

Многие разработчики писали, что весьма заинтригованы Svelte, но некоторые особенности его дизайна им не нравились. Например, использование таких функций, как вложенные компоненты или переходы, требует, чтобы вы *зарегистрировали* их, вот как выглядит подобный компонент:

```html
<div transition:fade>
  <Nested/>
</div>

<script>
  import { fade } from 'svelte-transitions';
  import Nested from './Nested.html';

  export default {
    components: { Nested },
    transitions: { fade }
  };
</script>
```

Объявление методов также несколько громоздко, и в различных IDE приводит к отображению ошибок, поскольку оно нарушает нормальную семантику JavaScript:

```html
<button on:click="doSomething()">click me</button>

<script>
  export default {
    methods: {
      doSomething() {
        // В VSCode показываетя ошибка "Property 'get'
        // does not exist on type {...}"
        const { foo } = this.get();
      }
    }
  };
</script>
```

Возможно, самая большая проблема в том, что у разметки нет доступа к произвольным значениям внутри тега `<script>`. Вместо этого значения должны быть специальным образом *сделаны доступными* для разметки, либо как свойства, переданные в компонент, либо как `data`, `helpers` или `computed` - три специфичные для Svelte концепции, которые местами пересекаются, и это путает некоторых людей:

```html
<h1>Hello {capitalise(name)}!</h1>
<p>Your name has {len} letters in it.</p>

<script>
  import { capitalise } from './utils.js';

  export default {
    data() {
      // эта функция вызывается для каждого экземпляра компонента
      // и предоставляет "базу" для начального состояния экземпляра, 
      // но любое свойство может быть переопределено извне
      return {
        name: 'world'
      };
    },

    helpers: {
      // хелперы по существу идентичны `data`, за исключением 
      // того, что их значения никогда не могут изменяться
      capitalise
    },

    computed: {
      // вычисляемые значения - это функции, которые повторно 
      // вызываются при изменении их зависимостей, но для 
      // разметки это просто еще один тип значениий
      len: ({ name }) => name.length
    }
  };
</script>
```

Есть объективные технические и исторические причины для такого построения компонента. И некоторые люди - особенно те, кто имеет опыт работы в Vue или Ractive - знакомы с этим и им это даже нравится. Но реальность такова, что для большинства из нас это отстой. Было бы гораздо приятнее сделать что-то вроде этого:

```html
<script>
  import { capitalise } from './utils.js';
  let name = 'world';
  const len = () => name.length;
</script>

<h1>Hello {capitalise(name)}!</h1>
<p>Your name has {len()} letters in it.</p>
```

Почему мы не можем так сделать? Из-за *реактивности*. У представления нет возможности 'узнать', изменилось ли `name`.


## Проблема реактивности

UI фреймворки  - все, в некоторой степени, являются примером реактивного программирования. Идея состоит в том, что представление можно рассматривать как результат функции от состояния приложения, и поэтому, когда ваше состояние меняется, предсталение должно на это реагировать - это смысл реактивности.

Реактивность реализуется различными способами (примечание: я не являюсь экспертом в таких фреймворках, кроме Svelte, пожалуйста, исправьте любые неправильные суждения):

* **React** заново перерисовывает все приложение при каждом изменении состояния. Это требует использования виртуального DOM, что, в свою очередь, требует виртуального DOM-реконсилера. Это эффектный, но неэффективный подход по трем причинам: во-первых, написаный код должен часто выполняться, давая маленьким ошибкам накапливаться в большой снежный ком, особенно если разработчик еще достаточно не опытен; во-вторых, виртуальный DOM сам по себе еще молодая штука, в-третьих, обнаружение 'того, что изменилось' с помощью сравнения состояний виртуального DOM, обычно весьма расточительно, особенно когда изменений было немного. Разумные люди могут не согласиться(и не соглашаются) с тем, что эти проблемы сильно влияют на конечное приложение, но хорошо известно, что наиболее простой способ сделать код быстрее - это сделать меньше работы, а React делает слишком много работы.

* **Vue** может отслеживать, какие значения изменились, используя геттеры и сеттеры (методы доступа). Другими словами, ваши данные образуют основу 'модели представления' с методами доступа, соответствующими начальным свойствам. Назначение одному из них - `vm.foo = 1` - планирует обновление. Такой код приятен для написания, но не лишен недостатков - он может привести к непредсказуемому поведению при передаче значений непосредственно в приложении, что способствует мутациям. Кроме того это включает в себя некоторые небольшие вычислительные и накладные расходы памяти, а также некоторые ошибки при установке пока неизвестных свойств (это будет исправлено в Vue 3 при помози прокси, но, предположительно, в ущерб поддержки IE).

* **Svelte** предоставляет каждому компоненту метод `set` (и соответствующий метод` get`), позволяющий разработчику вносить явные изменения состояния. (Эти изменения полностью синхронны, и это одновременно хорошо и плохо - хорошо, потому что ментальная модель и получаемые в результате трассировки стека просты, плохо, потому что это может привести к замусориванию компоновки, ошибочным жизненным циклам и зацикливаниям, которые нужно предугадывать.) Нужно слишком много кода, чтобы описать мутации или скопировать объекты, и делает полезные вещи, вроде первоклассной интеграция TypeScript, по существу недостижимыми.
  
Ни один из них не идеален. Но [мы то являемся компилятором](https://mobile.twitter.com/Rich_Harris/status/1057290365395451905), что означает, что в нашем наборе инструментов есть инструменты, уникальные только для Svelte. Что если бы мы могли решить вопрос с реактивностью *на уровне языка*?

Это предложение обрисовывает в общих чертах новое (насколько нам известно) решение, приносящее ряд существенных преимуществ:

* Более простой дизайн
* Меньше кода в приложении
* Меньшие бандлы
* Более простые и надежные жизненные циклы
* Реальные перспектывы первокласной поддержки TypeScript
* Четко определенные взаимосвязи между компонентами и их потребителями
* Возможность адоптировать такие идеи, как [time slicing и Suspense](https://auth0.com/blog/time-slice-suspense-react16/)


## Подробнее о дизайне

Рассмотрим компонент счетчика:

```html
<script>
  let count = 0;
</script>

<button on:click="{() => count += 1}">
  clicks: {count}
</button>
```

> Кавычки вокруг обработчика событий не нужны для Svelte, но оставлены для совместимости с подсветкой синтаксиса, не поддерживающей Svelte.

Здесь мы объявили одну переменную состояния, `count`, с начальным значением `0`. Код внутри блока `<script>` запускается **один раз для каждого экземпляра компонента, при его создании**.

При нажатии на кнопку, текст внутри кнопки должен обновиться, чтобы отразить текущее значение. Это может быть достигнуто путем планирования обновления после каждого выражения присваивания (это весьма просто обнаружить через обход AST), что приводит к чему-то, напоминающему этот псевдокод:

```js
button.addEventListener('click', () => {
  count += 1;
  __update('count');
});
```

`__update` - это предоставляемая фреймворком функция, которая заставляет представление обновляться при этом она знает, какие значения изменились. Реализация `__update` пока не важна, за исключением того, что надо отметить, что она запланирует обновление **асинхронно**, в отличие от текущей модели Svelte, по причинам, которые мы обсудим [чуть позже](#sync-vs-async-rendering).

Это преобразование кода также применяется к присваиваниям внутри блока `<script>`. Этот компонент...

```html
<script>
  let count = 0;
  const incr = () => {
    count += 1;
  };
</script>

<button on:click={incr}>
  clicks: {count}
</button>
```

...будет преобразован в нечто вроде этого:

```js
function create_main_fragment(component, ctx) {
  // ...код, который создает и поддерживает представление —
  // он практически не затрагивается данным предложением
}

const Component = defineComponent((__update) => {
  let count = 0;
  const incr = () => {
    count += 1;
    __update({ count: true });
  };

  return [
    // это задает `ctx` переменную для `create_main_fragment`
    () => ({ count })
  ];
}, create_main_fragment);
```

**Такое поведение может показаться удивительным, даже поначалу шокирующим.** Назначение переменной  в JavaScript не должно иметь никаких побочных эффектов, так что, возможно такая запись компонента им и не является - возможно в итоге это уже что-то другое - например, [SvelteScript](https://mobile.twitter.com/youyuxi/status/1057291776724271104). На практике, однако, разработчики охотно используют подобную 'магию'(если ее механизмы легко понять), которая делает их повседневную жизнь проще - такое можно наблюдать в React Hooks, системе реактивности Vue, подходе Immer к неизменным данным и бесчисленном множестве других примеров. Это подчеркивает необходимость того, чтобы это преобразование кода было хорошо документировано и разъяснено.


### Мутирующие объекты и массивы

Хотя рекомендуется использовать неизменяемые данные в компонентах, Svelte не должна заставлять разработчиков делать это. Присвоение чего-либо свойству объекта или элементу массива будет иметь такое же основное поведение - `a.b = c` вызовет обновление для `a`. Возможно, что изменения могут отслеживаться на более детальном уровне (т.е. отслеживание конкретно `a.b`, а не всего `a`, чтобы `<p>{a.d}</p>` не обновлялось), но это детали реализации, выходящие за рамки этого RFC.

Вызов методов массива *не* вызовет обновления этих массивов.

> `x = x` может использоваться для принудительного обновления `x`, в редких случаях это необходимо


### Свойства

Многие фреймворки (а также веб-компоненты) имеют концептуальное различие между 'свойствами' (значения, передаваемые в *компонент*) и 'состоянием', или иначе 'стейтом'(значения, которые являются внутренними для компонента). В Svelte такого нет и это недостаток.

Есть решение этой проблемы, но приготовьтесь - сначала оно может показаться немного странным:

```html
<script>
  export let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

Здесь мы экспортируем *договор* с внешним миром - мы говорим, что потребитель этого компонента может указать значение для `name`, но по умолчанию оно будет иметь значение `world`:

```html
<Hello name="everybody"/>
```

Это будет скомпилированно в подобный код:

```js
const Component = defineComponent((__update) => {
  let name = 'world';

  return [
    () => ({ name }),
    props => {
      if ('name' in props) name = props.name;
    }
  ];
}, create_main_fragment);
```

**Это злоупотребление синтаксисом**, но не хуже того как сейчас Svelte злоупотребляет выражением `export default`. Зато это весьма наглядно и легко понимается. Использование существующего синтаксиса, а не придумывание собственного, позволяет нам в полной мере использовать существующие инструменты и поддержку редакторов кода.

> Обычно в JavaScript `export` означает, что там, где импортируется этот модуль, можно прочитать указанное значение. В некотором смысле это так (как мы узнаем в разделе [API компонента](#component-api)), но здесь это также позволяет потребителю этого модуля *записать* значение. Вот почему мы говорим, что экспортируем *договор*, а не *значение*.

В итоге, у нас получилось **3 простых правила** для понимания кода в блоке `<script>` компонента Svelte:

* Код запускается один раз для каждого созданного экземпляра компонента
* Присвавивания в перемнные запускают обновление представления
* Обозначениые выражением `export` значения формируют договор компонента с внешним миром


### Жизненый цикл

Многие компоненты должны реагировать на *события жизненного цикла*. В настоящее время в Svelte есть четыре [хука жизненного цикла](https://svelte.technology/guide#lifecycle-hooks) - `onstate`, `oncreate`, `onupdate` и `ondestroy`.

Хук `oncreate` запускается *после* начального рендеринга, что означает, что нет способа (в Svelte 2) запустить установочный код сразу после создания экземпляра - это как раз то, что хочет исправить данное предложение. Как мы увидим, его все еще можно использовать, но во многих случаях 'oncreate' вообще становится не нужным.

Следующий код включает в себя некоторую работу(установка таймера), которую затем необходимо отменить(удалить таймер) при удалении компонента. Для этого мы импортируем функцию жизненного цикла `onDestroy` (больше не называемую 'хуком', чтобы избежать путаницы с React Hooks, которые имеют принципиально иной механизм):

```html
<script>
  import { onDestroy } from 'svelte';
  import { format_time } from './helpers.js';

  let time = new Date();

  const interval = setInterval(() => {
    time = new Date();
  }, 1000);

  onDestroy(() => {
    clearInterval(interval);
  });
</script>

<p>The time is {format_time(time)}</p>
```

Функция внутри `onDestroy` связана с экземпляром компонента, потому что она вызывается во время создания экземпляра; никакая магия компилятора при этом не задействована. Если она вызывается вне экземпляра, возникает ошибка. А кроме этого, нет никаких правил или ограничений относительно того, когда вызывается функция жизненного цикла. Поэтому у нас появляется возможность очень гибкого повторного использования кода:

```js
// helpers.js
import { onDestroy } from 'svelte';

export function useInterval(fn, ms) {
  const interval = setInterval(fn, ms);
  onDestroy(() => clearInterval(interval));
  fn();
}
```

```html
<script>
  import { useInterval, formatTime } from './helpers.js';

  let time;
  useInterval(() => time = new Date(), 1000);
</script>

<p>The time is {formatTime(time)}</p>
```

> Такой подход может показаться менее эргономичным, чем React Hooks, где вы можете сделать `const time = useCustomHook()`. Преимущество же состоит в том, что этот код не будет запускаться при каждом изменении состояния, и легче увидеть, какие значения в компоненте могут изменяться, и *когда* изменяется конкретное значение.

There are three other lifecycle functions required — `onMount` (similar to `oncreate` in Svelte v2), `beforeUpdate` (similar to `onstate`) and `afterUpdate` (similar to `onupdate`):

Также имеются и три другие необъодимые функции жизненного цикла - `onMount` (аналогично `oncreate` в Svelte v2), `beforeUpdate` (аналог `onstate`) и `afterUpdate` (аналог `onupdate`):

```html
<script>
  import { beforeUpdate, afterUpdate, onMount } from 'svelte';

  export let foo;

  beforeUpdate(() => {
    // запускается, когда изменилось какое-либо свойство
  });

  afterUpdate(() => {
    // запускается после того, как обновится представление
  });

  onMount(() => {
    // запускается единожды, после первого запуска `afterUpdate`

    return function() {
      // эта (опциональная) возвращаемая функция запускается 
      // при уничтожении экземпляра компонента,
      // позволяя ссылкам (вроде timeout и т.п.) 
      // оставаться внутри одной функции
      // и предотвращает основанную на DOM очистку 
      // кода, при работе в контексте SSR
    };
  });
</script>
```

> Обратите внимание на то, что аргументы `changed`, `current` и `previous`, присутствующие в Svelte 2, отсутствуют в сallback-функциях функций жизненного цикла - я считаю, что они теперь не нужны.

В настоящее время `onstate` и `onupdate` запускаются до и после каждого изменения состояния. Поскольку Svelte 2 не может отличить внешние свойства от внутреннего состояния, то это может легко привести к нежелательной зациклинности:

```js
<script>
  export default {
    data: () => ({
      temperature: 32,
      getting: null
    }),

    onstate({ changed, current, previous }) {
      if (changed.temperature && previous) {
        // этот вызов снова приведет к немедленному вызову `onstate`
        this.set({
          getting: current.temperature > previous.temperature
            ? 'warmer'
            : 'colder'
        });
      }
    }
  };
</script>
```

Согласно этому предложению функции внутри `beforeUpdate` запускаются только один раз за цикл. Это делает бесконечные циклы невозможными:

```html
<script>
  import { beforeUpdate } from 'svelte';

  export let temperature = 32;
  let getting = null;
  let previous_temperature;

  beforeUpdate(() => {
    // это присвоение *не* приведет к повторному вызову
    getting = temperature > previous_temperature
      ? 'warmer'
      : 'colder';

    previous_temperature = temperature;
  });
</script>
```

> Обратите внимание, если `previous_temperature` не используется в шаблоне, то она и не будет реактивной вообще.

Любые сallback-функции `afterUpdate` будут выполняться после обновления представления в результате изменения свойства или состояния. Присваивания в сallback-функции `afterUpdate` приведут к немедленной повторной отрисовке (после выполнения всех имеющихся сallback-функций в `afterUpdate` не дожидаясь следующей отрисовки), но *не* приведут к повторному запуску сallback-функции. Например, это позволяет компонентам реагировать на изменения макета.


---

В оставшейся части этого раздела будет рассмотрено, как существующие концепции Svelte затрагиваются данным RFC. Некоторые вещи (CSS и т. Д.) Не упоминаются, потому что они не затронуты, но, если по вашему мнению, что-то было упущено, пожалуйста, напишите об этом.


### Директивы

В Svelte 2 есть шесть различных видов директив:

* `on:[event]` и `on:[event]=[callExpression]`
* `use:[action]` и `use:[action]=[argument]`
* `ref:[name]`
* `in:[transition]`, `out:[transition]` и `transition:[transition]`, и `in:[transition]=[params]` и т.п.
* `bind:[name]` и `bind:remote=[local]`
* `class:[name]` и `class:[name]=[expression]`

В настоящее время значения директив не имеют фигурных скобок в качестве разделителей. Иногда это приводит к путанице (и сложности компилятора), которую можно устранить, сделав директивы более похожими на атрибуты:

```html
<!-- сейчас -->
<div class:foo="a ? b : c">...</div>

<!-- будет -->
<div class:foo="{a ? b : c}">...</div>
```

Несмотря на то, что мы используем два дополнительных символа (кавычки мы оставляем, чтобы посдветка синтаксиса все еще работала в редакторах, не поддерживающих Svelte), но код, как мне кажется, более читабелен и согласован. Подобный шаблон будет использоваться во всех директивах, но есть еще кое-какие изменения в `ref:` и `on:`, описаные ниже.


#### `ref:`

Директива `ref:`является аномальной в том смысле, что она не может иметь значение. Нас часто просили сделать следующую возможность - устанавливать `ref:` внутри блоков `each`. Мы можем убить двух зайцев, заодно сократив наше API - заменив `ref:x` на `bind:this={x}`:

```html
<canvas bind:this={canvas} {width} {height}></canvas>
```

В Svelte 2 к этому элементу можно получить доступ (после запуска `oncreate`) через `this.refs.canvas`. В соответствии с данным предложением значения в `ref:` являются простыми переменными:

```html
<script>
  import { afterUpdate } from 'svelte';

  export let width;
  export let height;
  let canvas;
  let ctx;

  afterUpdate(() => {
    if (!ctx) ctx = canvas.getContext('2d');
    draw_some_shapes(ctx);
  });
</script>
```

(Поскольку привязка может иметь любое значение [l-value](https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue), то мы также можем сделать `bind:this={array[index]}` внутри ,блоков `each`.)

Пример выше скомпилируется во что-то вроде этого:

```js
import { afterUpdate } from 'svelte';

const Component = defineComponent((__update) => {
  let width;
  let height;
  let canvas;
  let ctx;

  afterUpdate(() => {
    if (!ctx) ctx = canvas.getContext('2d');
    draw_some_shapes(ctx);
  });

  return [
    () => ({ width, height }),
    props => {
      if ('width' in props) width = props.width;
      if ('height' in props) height = props.height;
    },
    refs => {
      if ('canvas' in refs) canvas = refs.canvas;
    }
  ];
}, create_main_fragment);
```

То же самое относится к `ref:` на компонентах.


#### `on:`

В настоящее время встроенные обработчики событий должны вызываемыми выражениями...

```html
<button on:click="set({ x: x + 1 })">increment</button>
```
... и вызываемое выражение должно быть либо методом компонента, либо события, либо какой-либо еще допустимой штукой. Это странно и противоречиво - и сильно напрягает при изучении. Поскольку проблем с `this` больше нет, мы можем значительно упростить задачу, передав сразу функции, а не вызывать их:

```html
<button on:click="{() => x += 1}">increment</button>
```

Это позволяет нам делать довольно сложные вещи, вроде этой:

```
<input on:keydown="{e => e.which === 39 ? next(e) : e.which === 37 ? prev(e) : null}">
```

В Svelte 2 есть сокращение:

```html
<!-- эти строки эквивалентны: -->
<div on:click>...</div>
<div on:click="fire('click', event)">...</div>
```
Пока не ясно, следует ли нам сохранить это или полностью заменить его на всплытие(bubbling) событий, обсуждаемое [ниже](#events).

**Пользовательские события** в Svelte 2 позволяют использовать события определяемые пользователем в дополнение к встроенным событиям DOM:

```html
<div on:drag="handleDrag(event)">drag me</div>

<script>
  export default {
    events: {
      drag(node, callback) {
        // тут имплементация
      }
    }
  };
</script>
```

Они плохо ложатся на Svelte 3. Но мы можем сделать кое что покруче - вместо них мы можем использовать действия(actions):

```html
<script>
  import { drag } from 'svelte/gestures'; // 🐃 ???

  function handle_drag(arg) {...}
</script>

<div use:drag={handle_drag}>drag me</div>
```

> (Иконка 🐃, которая будет встречаться по всем RFC, обозначает английскую идиому "Побрить Яка" -  т.е. задачу, над которой необходимо подумать до того как Svelte 3 будет готова к выходу)

Сама система событий будет подробно обсуждаться [ниже](#events).


### Опции namespace/tag

Экспорт по умолчанию из компонента Svelte 2 может включать параметры компилятора - например, объявление `namespace`(для компонентов SVG) или `tag` (для [пользовательских элементов](https://learn.javascript.ru/webcomponent-core)):

```js
export default {
  namespace: 'svg',
  tag: 'my-cool-thing'
};
```

Согласно данному предложению эти параметры будут выражены новым специальным элементом `<svelte: meta>`:

```html
<svelte:meta namespace="svg" tag="my-cool-thing">
```

### Компоненты без <script>


В настоящее время можно создавать компоненты без блока `<script>`:

```html
<h1>Hello {name}!</h1>
```

Это удобно и просто, и должно быть сохранено. В соответствии с данным предложением  - любое значение, указанное в разметке, становится экспортируемой переменной - соответственно вышеприведенный код будет эквивалентен этому:

```html
<script>
  export let name;
</script>

<h1>Hello {name}!</h1>
```


### События

Компоненты Svelte 2 могут запускать события с помощью `this.fire(eventName, optionalData)`. Эти события можно ловить программно, с помощью `component.on(eventName, callback)` или декларативно в разметке компонента:

```html
<Widget on:flubber="doSomething()">
```

Поскольку больше нет `this`, то больше нет и `this.fire`, что означает, что нам нужно переосмыслить события. Это дает нам возможность прийти в соответствие с web-компонентами, где используется `CustomEvent` ([обсуждение тут](https://github.com/sveltejs/svelte/issues/1655)) - это также дает нам всплывающие события, которые позволяют больше не прокидывать события вручную.

Предложение состоит в том, чтобы ввести функцию с именем `createEventDispatcher`, которая будет возвращать функцию для вызова событий:

```js
import { createEventDispatcher } from 'svelte';

const dispatch = createEventDispatcher();

let i = 0;
const interval = setInterval(() => {
  dispatch(i++ % 2 ? 'tick' : 'tock', {
    answer: 42
  });
}, 1000);
```

Это создаст пользовательское событие с `event.type` равным `tick` (или `tock`) и `event.detail` равным объекту `{answer: 42}`.

> 🐃 Вместо этого мы можем привести аргументы в соответсвие с `new CustomEvent(name, opts)` - где `detail` будет одной из опций, передаваемых конструктору вместе с такими опциями, как `bubbles` и `cancellable`

> Обратите внимание, что `new CustomEvent` не поддерживается в IE; в режиме совместимости придется использовать `document.createEvent('whatever')`

Как и в случае функций жизненного цикла, переменная `dispatch` будет привязана к компоненту, потому что в нем вызывается `createEventDispatcher`.



### API компонента

Согласно данному предложению, *внутри* компонента больше нет `this` с состоянием и методами. Но должен быть способ взаимодействия с компонентом из внешнего мира.

Создание корневого компонента остается таким же, за исключением того, что `data` переименовывается в `props`, чтобы соответствовать языку, используемому в других местах:

```js
import App from './App.html';

const app = new App({
  target: document.querySelector('body'),
  props: {
    name: 'world'
  }
});
```

Экспортированные свойства могут быть представлены как аксессоры:

```js
app.name; // world
app.name = 'everybody'; // сразу запускает обновление
```

Это создает согласованное поведение между компонентами Svelte, которые компилируются в пользовательские элементы, и теми, которые не являются таковыми, а также упрощает понимание *договора* компонента.

Из пяти **встроенных методов**, которые в настоящее время включают [API компонента](https://svelte.technology/guide#component-api) - `fire`, `get`, `set`, `on` и `destroy` - нам больше не нужны первые два. `on` и `destroy` по-прежнему необходимы, и мы оставим `set` для случаев, когда кому-то нужно поменять сразу несколько свойств вызвав при этом только одно обновление.

Чтобы отличить эти встроенные методы от обычных свойств (чтобы не нужно было беспокоиться о потенциальных конфликтах), `on`, `destroy` и `set` станут соответственно `$on`, `$destroy` и `$set`.

В некоторых случаях компонент, предназначенный для использования в качестве автономного виджета, будет создавать свои собственные **пользовательские методы**. В Svelte 2 они объединены с 'приватными' методами(на самом деле нет). Согласно этому предложению, пользовательские методы - это просто экспортированные переменные, которые являются функциями:

```html
<script>
  let visible;

  export function show() {
    visible = true;
  }

  export function hide() {
    visible = false;
  }
</script>

<div class="peekaboo">
  {#if visible}
    <p>now you see me</p>
  {/if}
</div>
```

```js
import Peekaboo from './Peekaboo.html';

const peekaboo = new Peekaboo(...);
peekaboo.show();
```
Выражения `export const`, `export function` и `export class` будут сигналом для компилятора, что такое свойство доступно только для чтения - другими словами, попытка присвоить ему значениие приведет к ошибке.


### `preload` и `setup`

В Svelte 2 есть довольно неуклюжий механизм объявления статических свойств в конструкторе компонента - хук `setup`:
```html
<script>
  export default {
    setup(Component) {
      Component.staticMethod = () => {...};
    }
  };
</script>
```

Это очень странно, и из-за упущения (которое мы не можем исправить без серьезных изменений) работает только на клиенте.

Так как [Sapper](https://sapper.svelte.technology/) требует, чтобы компоненты имели какой-то способ объявить свои зависимости данных перед рендерингом, но поскольку `setup` слишком громоздкая, пришлось выдумать специальную штуку - `preload`. Функция `preload` прикреплена к компонентам на клиенте и сервере и не имеет четко определенного поведения; это просто соглашение.

Мы можем сделать лучше, **но это требует кое-чего потенциально противоречивого** - второй блок `<script>`, который, в отличие от того, который мы использовали до сих пор, запускается только один раз для компонента, а не при каждом создании экземпляра этого  — `context="module"`:

```html
<script context="module">
  export function preload({ params }) {
    return this.fetch(`data/${params.id}.json`).then(r => r.json()).then(things => {
      return { things };
    });
  }
</script>

<script>
  export let things;
</script>

{#each things as thing}
  <p>{thing}</p>
{/each}
```

`things` будут вставлены в блок `<script>` в экземпляре в то же время, что и свойства (то есть между созданием экземпляра и первым рендерингом).

Все, что экспортируется из `context="module"`, будет доступно для других модулей обычным способом:

```js
import Widget, { preload } from './Widget.html';

Promise.resolve(preload(params)).then(props => {
  widget = new Widget({
    target,
    props
  });
});
```

Экспорт по умолчанию будет запрещен, поскольку сам компонент и есть экспорт по умолчанию.

> Концептуально, `context="module"` - это вроде бы как раз идеальное место для размещения любых функций, которые совместно используются экземплярами компонента. Но на самом деле это делать необязательно, компилятор автоматические шарит подобные функции между экземплярами(если в них нет ссылок на внутреннее состояние), предотвращая таким образом дублирование кода.


### Рендеринг на стороне сервера

Компилятор, работающий с опцией `generate: 'ssr'`, генерирует совершенно другой код, чем с опицией `generate:' dom'`. Это связано с тем, что компоненты, отображаемые на сервере, не имеют жизненного уикла - они ренедрятся, а затем сразу выгружаются.  И вместо понятия 'экземпляр компонента', компонент при SSR экспортирует функцию, которая, на основе входных данных, создает HTML и CSS.

Это, однако, создает некоторые тонкие в поведении компонента: нет определенного места для выполнения какой-либо первоначальной работы по настройке, а `oncreate` (и прочие хуки жизненного цикла) никогда не запускаются. Привязки компонентов также являются весьма ненадежнымми.

В соответствии с данным предложением код внутри блока `<script>` *будет* выполняться при рендеринге на сервере, значит нужно будет запускать и функцию `ondestroy`. В то же время `onMount`, `beforeUpdate` и `afterUpdate` не будут запускаться при серверном рендеринге.

API останется прежним (мы экспериментировали с методом экспорта функции SSR `$render` из обычного компонента, но это оказалось нецелесообразным по разным причинам).


### Хранилище

[Хранилище](https://svelte.technology/guide#state-management) может быть присоединено к компоненту, и оно будет передано всем его дочерним элементам. Это позволяет компонентам получать доступ и манипулировать данными уровня приложения без необходимости передавать свойства между собой. Svelte 2 предоставляет удобный синтаксис `$` для ссылки на свойства в хранилище:

```html
<h1>Hello {$name}!</h1>
```

Аналогично, методы хранилища могут быть вызваны через прослушиватели событий:

```html
<button on:click="$set({ count: count + 1 })">increment</button>
```

Хранилище также доступно и из кода:

```js
const { foo } = this.store.get();
this.store.doSomething();
```

Поскольку больше нет `this`, нам необходимо пересмотреть этот подход. В то же время интерфейс `get`/`set`/`on`/`fire` (зеркальное отражение API компонента) выглядит теперь несколько устаревшим в свете остальной части этого RFC. Основная проблема с хранилищем в его нынешнем воплощении - отсутствие удобства проверки типов и недокументированные костыли, необходимые для интеграции с популярными библиотеками, такими как MobX.

Предложение о замене хранилища существует в форме [RFC 2](https://github.com/sveltejs/rfcs/pull/5).


### Размазывание свойств

Удобно иметь возможность передавать свойства от родительского к дочернему компоненту, не вникая в их содержимое. В Svelte 2 мы можем сделать так - выглядит коряво, но работает:

```html
<!-- Lazy.html -->
{#await loader() then mod}
  <svelte:component this={mod.default} {...props}/>
{/await}

<script>
  export default {
    computed: {
      props: ({ loader, ...props }) => props
    }
  };
</script>
```

Эта возможность больше не существует в этом RFC. Вместо этого нам нужен какой-то другой способ выразить концепцию 'всех свойств, которые были переданы в этот компонент'. Одним из предложений является использование директивы `bind` для (🐃) элемента `<svelte:meta>`, описанного выше:

```html
<svelte:meta bind:props/>

<script>
  import Foo from './Foo.html';
  import Bar from './Bar.html';

  let props;

  const subset = () => {
    const { thingIDontWant, ...everythingElse } = props;
    return everythingElse;
  };
</script>

<Foo {...props}/>
<Bar {...subset()}/>
```


### Синхронный и асинхронный рендеринг

Одна из вещей, которая отличает Svelte от других сред, заключается в том, что обновления являются синхронными. Другими словами:

```js
app.set({ size: 'supersize' });
console.log(app.refs.box.offsetWidth); // значение будет уже обновлено
```

Это легко понять, и, если во время рендеринга возникает ошибка, легко выделить источник проблемы, так как обычно трассировка до вызова `set` имеет довольно короткий стек.

Но в то же время есть и серьезные недостатки. Такая схема может привести к зацикливаниям, как мы видели выше, и не дает фреймворку возможности оптимизировать обновления с помощью (например) выноса операций, которым нужно читать DOM (таким callback-функции переходов или `onupdate`) отдельно от инициированного фреймворком циклом записи в DOM. Это также не позволяет нам реализовывать такие идеи, как [распределение по времени](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html).

Кроме того, хоть и возможно создать пакетное изменение *внутри компонента* (`this.set({ a, b, c })` приводет к одному обновлению представления), изменения *между* компонентами (или теми, которые влияют одновременно на хранилище и компонент) ) не могут быть сгруппированы. Теперь, когда у нас нет `set`, важно, чтобы изменение переменных не приводило к одновременному обновлению представления, а скорее планировало обновление (в микрозадаче).

В случае необходимости должна быть возможность сделать исключение из этого правила. Например, если вы отслеживаете высоту списка ...

```html
<script>
  import { afterUpdate } from 'svelte';

  export let items = [];
  let list;
  let listHeight = 0;

  afterUpdate(() => {
    listHeight = list.offsetHeight;
  });
</script>

<p>the list is {listHeight}px tall:</p>

<ul ref:list>
  {#each items as item}
    <li>{item}</li>
  {/each}
</ul>
```

... тогда вы хотите, чтобы изменение в `listHeight` отражалось в представлении, как только сработали все callback-функции в `onupdate`, а *не* после отрисовки (что привело бы к задержке).

Точно так же, с точки зрения публичного API компонента, для `customElement.foo = 1` может потребоваться синхронное обновление.


### Suspense(Ожидание)

Данное предложение не имеет прямого отношения к [реализации Suspense](https://github.com/sveltejs/svelte/issues/1736), но следует позаботиться о том, чтобы Suspense можно было внедрить поверх этого предложения, не внося существенных изменений.


### TypeScript

Основным преимуществом этого предложения по сравнению со Svelte 2 является то, что компоненты становятся гораздо более пригодными для проверки типов и других форм статического анализа. Даже без TypeScript, VSCode может предложить гораздо более богатую обратную связь, чем со Svelte 2.

Конечная цель состоит в том, чтобы иметь возможность использовать TypeScript в компонентах:

```html
<script lang="typescript">
  export let name: string;
</script>

<h1>Hello {name}!</h1>
```

Редактор в идеале должен предлагать автозаполнение и проверку типов по мере ввода внутри разметки. Однако это не моя область знаний, поэтому я хотел бы получить отзывы об этом предложении от людей, которые лучше знакомы с API компилятора TypeScript и его экосистемой.

### Пользовательские элементы

В Svelte останется возможность компиляции компонентов в пользовательские элементы. Здесь не будет никаких реальных изменений, так как это предложение приводит 'ванильные' компоненты Svelte в соответствие с веб-компонентами, а именно - доступ к свойствам и обработка событий.

Опция компилятора `props` теперь избыточна, когда 'договор' определяется с помощью переменных, обозгаченных выражением `export`. Опция `tag` может быть установлена ​​через `<svelte: meta>`, как обсуждалось выше.


### Отслеживание зависимостей

В Svelte 2 'вычисляемые свойства' используют отслеживание зависимостей во время компиляции для получения значений из состояния, избегая повторного вычисления, когда зависимости не изменяются. Однако, перевычисление такиъ свойств зависит от того, что в них вложено, а не от того факта что их где-то запрашивают, что может привести к ненужной работе:
```html
{#if visible}
  <p>{bar}</p>
{/if}

<script>
  export default {
    data: () => ({
      foo: 1,
      visible: false
    }),

    computed: {
      bar: ({ foo }) => expensivelyCalculateBar(foo)
    }
  };
</script>
```

В приведенном выше примере нет реальной необходимости вычислять `bar`, так как он не отображается, но это все равно происходит.

[RFC 3](https://github.com/sveltejs/rfcs/pull/8) предлагает альтернативу вычисляемым свойствам в Svelte 3, которая является более гибкой и требует меньшее количество кода.

### svelte-extras

Большинство методов в [svelte-extras](https://github.com/sveltejs/svelte-extras) больше не актуальны. Два мет ода, которые мы хотим переопределить - это `tween` и `spring`.

К счастью, они больше не будут включать патчинг методов компонента:

```html
<script>
  import { beforeUpdate } from 'svelte';
  import { tween } from 'svelte/motion';
  import * as eases from 'eases-jsnext';

  export let progress = 0;
  let tweenedProgress = 0;

  let t;

  beforeUpdate(() => {
    if (t) t.stop();

    t = tween(tweenedProgress, progress, {
      easing: eases.cubicOut,
      duration: 200
    }, value => {
      tweenedProgress = value;
    });
  });
</script>

<progress value={tweenedProgress}/>
```


### Примеры


'Будущие' компоненты хоть и являются ссылками REPL, но они не заработают в REPL (очевидно) - просто так легче представить 'до' и 'после'.

* редактор разметки [сейчас](https://svelte.technology/repl?version=2.15.0&demo=binding-textarea) / [будет](https://svelte.technology/repl?version=2.15.0&gist=a0443aa0fc68947b5fad8fae1aa63627)
* media-элементы [сейчас](https://svelte.technology/repl?version=2.15.0&demo=binding-media-elements) / [будет](https://svelte.technology/repl?version=2.15.0&gist=8562a70e1a1e708b735b7a50e80b3cfe)
* вложенные компоненты [сейчас](https://svelte.technology/repl?version=2.15.0&demo=nested-components) / [будет](https://svelte.technology/repl?version=2.15.0&gist=cbad006c2197633ac75fc8f31c3670df)
* SVG часы [сейчас](https://svelte.technology/repl?version=2.15.0&demo=svg-clock) / [будет](https://svelte.technology/repl?version=2.15.0&gist=758aacc71f506518a70c0e42f0735f6c)
* Простой переход [сейчас](https://svelte.technology/repl?version=2.15.0&demo=transitions-fade) / [будет](https://svelte.technology/repl?version=2.15.0&gist=7bd7b4349a27342ca96b58046eb6e765)
* Пользовательский переход [сейчас](https://svelte.technology/repl?version=2.15.0&demo=transitions-custom) / [будет](https://svelte.technology/repl?version=2.15.0&gist=2e9830aad338305877d226d80a9d04d4)
* Конвертер температуры [сейчас](https://svelte.technology/repl?version=2.15.0&demo=7guis-temperature) / [будет](https://svelte.technology/repl?version=2.15.0&gist=439fc5e7c89d91a31c9c9c1447434532)


## Как мы будем этому учить

Успех этой идеи зависит от того, сможем ли мы объяснить, как работают **реактивные присваивания**, разработчикам, которые не являются спецами в нашем компиляторе. Это означает появление множества примеров, которые предлагают объяснение скомпилированного вывода, чтобы разработчики могли понять, что происходит с их кодом, даже если им это не особо нужно.

Также важно иметь кучу примеров, показывающих, как существующие шаблоны проектирования Svelte могут быть реализованы в этом новом мире.


## Недостатки

Очевидно, это серьезное 'ломающее' изменение. Мы не команда React; у нас нет ресурсов для поддержки двух отдельных парадигм.

Данное предложение приносит также некоторое откровенно удивляющее поведение. Потратив большую часть недели на размышления об этом и играя с существующими компонентами, после преодоления первоначального шока, мне такой подход уже кажется естественным, но не могу гарантировать, что все будут чувствовать так же.

Однако в целом RFC решает такое количество взаимосвязанных проблем со Svelte, что я считаю, что преимущества будут огромными.


## Альтернативы


Мы играли с несколькими альтернативными концепциями:

* Ничего не предпринимать и пытаться исправлять что получится в рамках текущей парадигмы
* Адоптация чего-то похожего на React Hooks. Это было встречено негативной реакцией сообщества. Несмотря на некоторые незначительные эргономические преимущества в некоторых случаях, недостатки React Hooks ('правила', зависимость от многократного вызова пользовательского кода и т.п.) перевешивали эти преимущества
* Стремление к более чистому видению реактивного программирования, сродни [описанному Полом Стовеллом](http://paulstovell.com/blog/reactive-programming). Но это, возможно, сделает код более трудным для понимания, не уменьшит его количество, и, вероятно, введет сложные синтаксические требования

## Нерешенные вопросы

Вроде нет
