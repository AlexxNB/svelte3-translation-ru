---
title: Формат компонента
---

---

Компоненты — это строительные кирпичики любого приложения на фреймворке Svelte. Они описываются в файлах с расширением `.svelte` при помощи надмножества языка разметки HTML.

Все три части — script, style и разметка — не являются обязательными.

```html
<script>
	// логика описывается здесь
</script>

<style>
	/* стили должны быть здесь */
</style>

<!-- разметка (0 или более элементов) помещается здесь -->
```

### &lt;script&gt;

Блок `<script>` содержит JavaScript, который запускается при создании экземпляра компонента. Переменные, объявленные (или импортированные) в этом блоке, 'видны' из разметки компонента. Есть ещё четыре дополнительных правила:

##### 1. `export` объявляет свойство компонента

---

Svelte использует ключевое слово `export`, чтобы пометить объявление переменной как *свойство*, что означает, что оно становится доступным извне всему, что будет использовать этот компонент:

```html
<script>
	// эти свойства могут быть заданы извне
	export let foo;
	export let bar = 'опциональное значение по умолчанию';

	// Значения переменных, объявленных как свойства,
	// доступны сразу же
	console.log(foo, bar);

	// функции не могут быть установлены извне,
	// но доступны для исполнения
	export function instanceMethod() {
		alert(foo);
	}
</script>
```

##### 2. Присваивания 'реактивны'

---

Чтобы изменить состояние компонента и запустить его перерисовку, просто присвойте что-либо переменной, объявленной локально.

Присваивания с обновлением (`count += 1`) и присваивания свойствам (`obj.x = y`) будут иметь тот же эффект.

```html
<script>
	let count = 0;

	function handleClick () {
		// вызов этой функции приведет к перерисовке компонента,
		// если в разметке есть ссылка на `count`
		count = count + 1;
	}
</script>
```

##### 3. `$:` делает выражение реактивным

---

Любое выражение на верхнем уровне (то есть не внутри блока или функции) можно сделать реактивным, добавив к нему префикс `$:`. Реактивные выражения запускаются непосредственно перед обновлением компонента всякий раз, когда изменяются значения переменных, которые в него входят.

```html
<script>
	export let title;

	// это выражение будет обновлять `document.title` каждый раз,
	// когда свойство `title` изменится
	$: document.title = title;

	$: {
		console.log(`можно объединить в блок несколько выражений`);
		console.log(`текущий заголовок: ${title}`);
	}
</script>
```

---

Если выражением является только присваивание значения ранее не объявленной переменной, Svelte самостоятельно предварительно объявит такую переменную через оператор `let`.

```html
<script>
	export let num;

	// нет необходимости объявлять `squared` и `cubed`,
	// Svelte сделает это за нас
	$: squared = num * num;
	$: cubed = squared * num;
</script>
```

##### 4. Добавьте префикс `$` к хранилищу для получения его значения

---

Каждый раз, когда вам нужно взять значение из хранилища, вы можете вы можете сделать это, поместив перед ним префикс с символом `$`. Это говорит Svelte, что нужно объявить переменную с префиксом и подписаться на хранилище с автоматическим удалением подписки при необходимости.

Обратите внимание, что хранилище должно быть объявлено на верхнем уровне компонента, а не, например, внутри функции или блока `if`.

Локальные переменные (которые не являются ссылкой на хранилище) *не должны* иметь префикс `$`.

```html
<script>
	import { writable } from 'svelte/store';

	const count = writable(0);
	console.log($count); // выведет 0

	count.set(1);
	console.log($count); // выведет 1
</script>
```


### &lt;script context="module"&gt;

---

Блок `<script>` с атрибутом `context="module"` выполняется только один раз при первичной обработке модуля, а не при каждой инициализации экземпляров компонента. Значения, объявленные в этом блоке, доступны в разметке компонента и в обычном блоке `<script>`(но не наоборот).

Все, что экспортируется из такого блока с помощью оператора `export`, становится экспортом из самого скомпилированного  модуля.

Вы не сможете сделать `export default`, потому что сам компонент уже является экспортом по-умолчанию.

```html
<script context="module">
	let totalComponents = 0;

	// такая запись позволит импортировать в нужном месте эту функцию:
	// `import Example, { alertTotal } from './Example.svelte'`
	export function alertTotal() {
		alert(totalComponents);
	}
</script>

<script>
	totalComponents += 1;
	console.log(`для этого компонента было создано ${totalComponents} экземпляр(ов)`);
</script>
```


### &lt;style&gt;

---

CSS стили внутри блока `<style>` будут изолированы внутри данного компонента.

Это достигается путём добавления класса ко всем затронутым элементам, имя которого получено хэш-функцией из стилей компонента (например, `svelte-123xyz`).

```html
<style>
	p {
		/* это затронет только элемент <p> в этом компоненте */
		color: burlywood;
	}
</style>
```

---

Для применения стиля к селектору глобально, используйте модификатор `:global(...)`.

```html
<style>
	:global(body) {
		/* этот стиль для <body> */
		margin: 0;
	}

	div :global(strong) {
		/* этот стиль будет применяться ко всем элементам <strong> 
		   в любом компоненте, который находится внутри 
	       элементов <div> данного компонента */
		color: goldenrod;
	}
</style>
```