---
title: Формат компонента
---

---

Компоненты — это строительные кирпичики любого приложения на фреймворке Svelte. Они описываются в файлах с расширением `.svelte` при помощи надмножества языка разметки HTML.

Все три части — script, style и разметка — не являются обязательными.

```html
<script>
	// логика описывается здесь
</script>

<style>
	/* стили должны быть здесь */
</style>

<!-- разметка (0 или более элементов) помещается здесь -->
```

### &lt;script&gt;

Блок `<script>` содержит JavaScript, который запускается при создании экземпляра компонента. Переменные, объявленные (или импортированные) в этом блоке, 'видны' из разметки компонента. Есть ещё четыре дополнительных правила:

##### 1. `export` объявляет свойство компонента

---

Svelte использует ключевое слово `export`, чтобы пометить объявление переменной как *свойство*, что означает, что оно становится доступным извне всему, что будет использовать этот компонент (см. раздел [Атрибуты и свойства](docs#Atributy_i_svojstva) для дополнительной информации).

```html
<script>
	export let foo;

	// Значения переменных, объявленных как свойства,
	// доступны сразу же
	console.log({ foo });
</script>
```

---
Можно указать значение по умолчанию, которое будет использоваться, в случае когда потребитель компонента задаст это свойство.
В режиме разработки (см. [параметры компиляции](docs#svelte_compile)), если потребитель не укажет значения свойства и, при этом не будет значения по умолчанию, будет показано предупреждение об ошибке. Чтобы оно не появлялось, убедитесь, что для свойства задано значение по умолчанию, даже если оно равно `undefined`.

```html
<script>
	export let bar = 'необязательное значение по умолчанию';
	export let baz = undefined;
</script>
```

---

При экспорте свойств заданных ключевыми словами `const`, `class` или `function`, снаружи они будут доступны только для чтения. В то же время, *функциональные выражения* являются обычными свойствами.


```html
<script>
	// доступны только для чтения
	export const thisIs = 'readonly';

	export function greet(name) {
		alert(`hello ${name}!`);
	}

	// обычное свойство
	export let format = n => n.toFixed(2);
</script>
```

---

Есть возможность использовать зарезервированные слова в качестве имен свойств.

```html
<script>
	let className;

	// создает свойство с именем  `class`, 
	// которое является зарезервированным словом в JS
	export { className as class };
</script>
```

##### 2. Присваивания 'реактивны'

---

Чтобы изменить состояние компонента и запустить его перерисовку, просто присвойте что-либо переменной, объявленной локально.

Присваивания с обновлением (`count += 1`) и присваивания свойствам (`obj.x = y`) будут иметь тот же эффект.

Поскольку реактивность Svelte основана на присваиваниях, использование таких методов массива, как `.push()` и `.splice()`, не приведёт к автоматическому обновлению. Но вы можете узнать в [учебнике](tutorial/updating-arrays-and-objects), как обойти это ограничение.

```html
<script>
	let count = 0;

	function handleClick () {
		// вызов этой функции приведёт к обновлению компонента,
		// если в разметке есть ссылка на `count`
		count = count + 1;
	}
</script>
```

##### 3. `$:` делает выражение реактивным

---

Любое выражение на верхнем уровне (то есть, не внутри блока или функции) можно сделать реактивным, добавив перед ним [JS метку](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/label) `$:`. Реактивные выражения запускаются непосредственно перед обновлением компонента всякий раз, когда изменяются значения переменных, которые в него входят.

```html
<script>
	export let title;

	// это выражение будет обновлять `document.title` каждый раз,
	// когда свойство `title` изменится
	$: document.title = title;

	$: {
		console.log(`можно объединить в блок несколько выражений`);
		console.log(`текущий заголовок: ${title}`);
	}
</script>
```

---

Если выражением является только присваивание значения ранее не объявленной переменной, Svelte самостоятельно объявит такую переменную через оператор `let`.

```html
<script>
	export let num;

	// нет необходимости объявлять `squared` и `cubed`,
	// Svelte сделает это за нас
	$: squared = num * num;
	$: cubed = squared * num;
</script>
```

##### 4. Добавьте префикс `$` к хранилищу для получения его значения

---
Хранилищем является любой объект, который допускает реактивный доступ к своему значению посредством так называемого *контракта хранилища*.

[Модуль `svelte/store`](docs#svelte_store) содержит минимальную реализацию хранилищ, соответствующих такому контракту. 

Каждый раз, когда вам нужно взять значение из хранилища, вы можете вы можете сделать это, поместив перед ним префикс с символом `$`. Это говорит Svelte, что нужно объявить переменную с префиксом и подписаться на хранилище с автоматическим удалением подписки при необходимости.

Присваивание значений переменным с префиксом `$` требует, чтобы эти переменные являлись записываемыми хранилищами, и приведёт к вызову метода хранилища `.set`.

Обратите внимание, что хранилище должно быть объявлено на верхнем уровне компонента, а не, например, внутри функции или блока `if`.

Локальные переменные (которые не являются ссылкой на хранилище) *не должны* иметь префикс `$`.

```html
<script>
	import { writable } from 'svelte/store';

	const count = writable(0);
	console.log($count); // выведет 0

	count.set(1);
	console.log($count); // выведет 1

	$count = 2;
	console.log($count); // выведет 2
</script>
```

##### Контракт хранилища

```js
store = { subscribe: (subscription: (value: any) => void) => () => void, set?: (value: any) => void }
```

Вы можете создавать собственные варианты хранилищ, без участия [`svelte/store`](docs#svelte_store), реализовав *контракт хранилища*:

1. Хранилище обязано иметь метод `.subscribe`, который должен принимать в качестве аргумента функцию подписки. При вызове этого метода, сразу же синхронно должна быть вызвана функция подписки, с передачей ей текущего значения хранилища. Далее все полученные функции подписки должны синхронно вызываться при любом изменении значения хранилища.
2. Метод `.subscribe` должен возвращать функцию отмены подписки. Вызов функции отмены должен привезти к тому, что соответствующая функция подписки более не должна вызываться хранилищем.
3. *По желанию*, хранилище может иметь метод  `.set`, который должен принимать параметром новое значение для хранилища и синхронно вызывать все активные функции подписки. Такое хранилище называется *записываемым хранилищем*. 

Для обеспечения совместимости с RxJS Observables метод `.subscribe` может возвращать объект с методом ` .unsubscribe`, вместо непосредственно функции отписки. Но если метод `.subscribe` вызывает подписку асинхронно(спецификация Observable это допускает), Svelte будет видеть значение хранилища как `undefined`, пока вызов не завершится.

---


### &lt;script context="module"&gt;

---

Блок `<script>` с атрибутом `context="module"` выполняется только один раз при первичной обработке модуля, а не при каждой инициализации экземпляров компонента. Значения, объявленные в этом блоке, доступны в разметке компонента и в обычном блоке `<script>`(но не наоборот).

Все, что экспортируется из такого блока с помощью оператора `export`, становится экспортом из самого скомпилированного  модуля.

Вы не сможете сделать `export default`, поскольку экспортом по умолчанию является сам компонент.

> Переменные, объявленные в блоке `context="module"`, не являются реактивными, поэтому присваивание им новых значений не будет приводить к перерисовке компонента, хоть сами переменные и обновятся. Для значений, которые предполагается использовать в нескольких компонентах, лучше использовать [хранилища](docs#svelte_store).


```html
<script context="module">
	let totalComponents = 0;

	// такая запись позволит импортировать в нужном месте эту функцию:
	// `import Example, { alertTotal } from './Example.svelte'`
	export function alertTotal() {
		alert(totalComponents);
	}
</script>

<script>
	totalComponents += 1;
	console.log(`для этого компонента было создано ${totalComponents} экземпляр(ов)`);
</script>
```


### &lt;style&gt;

---

CSS стили внутри блока `<style>` будут изолированы внутри данного компонента.

Это достигается путём добавления класса ко всем затронутым элементам, имя которого получено хэш-функцией из стилей компонента (например, `svelte-123xyz`).

```html
<style>
	p {
		/* это затронет только элемент <p> в этом компоненте */
		color: burlywood;
	}
</style>
```

---

Для применения стиля к селектору глобально, используйте модификатор `:global(...)`.

```html
<style>
	:global(body) {
		/* этот стиль для <body> */
		margin: 0;
	}

	div :global(strong) {
		/* этот стиль будет применяться ко всем элементам <strong> 
		   в любом компоненте, который находится внутри 
	       элементов <div> данного компонента */
		color: goldenrod;
	}
</style>
```

---

Если требуется сделать глобальной анимацию @keyframes, добавьте к имени анимации префикс `-global-`.

Часть имени `-global-` будет удалена при компиляции, и вы сможете обратиться к анимации просто по имени `my-animation-name` в любом месте вашего кода.

```html
<style>
	@keyframes -global-my-animation-name {...}
</style>
```
