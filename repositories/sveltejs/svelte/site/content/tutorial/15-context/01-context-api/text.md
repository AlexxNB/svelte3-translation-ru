---
title: setContext и getContext
---

API контекста предоставляет механизм, позволяющий компонентам 'разговаривать' друг с другом, не передавая данные и функции через свойства, и не генерируя множество событий. Это одна из дополнительных возможностей, но она может быть полезной.

Пусть у нас есть приложение, которое показывает карту [Mapbox GL](https://docs.mapbox.com/mapbox-gl-js/overview/). Нам нужно нанести на карту маркеры при помощи компонента `<MapMarker>`. Но для этого нам придется передавать ссылку на объект Mapbox через свойство в каждый экземпляр этого компонента.

API контекста состоит из двух методов - `setContext` и `getContext`. Если компонент вызывает `setContext(key, context)`, то любой *дочерний* компонент может получить нужный контекст с помощью `const context = getContext(key)`.

Давайте сначала установим контекст. В `Map.svelte` импортируйте `setContext` из `svelte` и `key` из `mapbox.js`, затем вызовите `setContext`:

```js
import { onMount, setContext } from 'svelte';
import { mapbox, key } from './mapbox.js';

setContext(key, {
	getMap: () => map
});
```

Объект контекста может быть чем угодно. Как и в случае с [функциями жизненного цикла](tutorial/onmount), `setContext` и `getContext` должны вызываться только во время инициализации компонента. Поскольку переменная `map` не существует, пока компонент не будет смонтирован, наш контекстный объект содержит функцию `getMap`, а не саму `map`.

Теперь на другом конце, в `MapMarker.svelte`, мы можем получить ссылку на экземпляр Mapbox:

```js
import { getContext } from 'svelte';
import { mapbox, key } from './mapbox.js';

const { getMap } = getContext(key);
const map = getMap();
```

Маркеры теперь могут добавлять сами себя на карту.

> Более законченная версия `<MapMarker>` также должна поддерживать удаление и изменение маркеров, но здесь мы просто демонстрируем работу с контекстом.

## ключи контекста

В `mapbox.js` вы можете найти такую строку:

```js
const key = {};
```

В качестве ключа мы можем использовать что угодно - например, очевидный вариант использовать строку `setContext('mapbox', ...)`. Но тут может случиться ситуация, когда разные библиотеки компонентов могут случайно использовать одинаковую строку в качестве ключа. Использование литерала объекта `{}` *гарантирует* отсутствие подобных конфликтов (объекты можно сравнивать только по его ссылкам, т.е. `{} !== {}` в то время, как `"x" === "x"`), даже при большом числе различных контекстов, работающих через несколько компонентных слоёв.

## Контекст vs. хранилище

Контекст и хранилища кажутся похожими. Они отличаются тем, что хранилища доступны в *любой* части приложения, в то время как контекст доступен только для *компонента и его потомков*. Это может быть полезно, если вы хотите использовать несколько копий компонента, чтобы состояние одного не влияло на состояние других.

Впрочем, их можно использовать и совместно. Поскольку контекст не реактивен, значения, которые будут изменяться со временем, можно поместить в хранилища внутри контекста:

```js
const { these, are, stores } = getContext(...);
```
