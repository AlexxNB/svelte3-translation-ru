- Start Date: 2018-11-28
- RFC PR: [#8](https://github.com/sveltejs/rfcs/pull/8)
- Svelte Issue: (leave this empty)

# Реактивные объявления

## Резюме

В этом RFC предлагается реализация аналога 'destiny оператора' внутри компонентов Svelte с использованием малоизвестной и редко используемой функции JavaScript под названием [labels](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label):

```html
<script>
  let count = 1;
  let doubled;
  let quadrupled;

  $: doubled = count * 2;
  $: quadrupled = doubled * 2;
</script>

<p>Twice {count} is {doubled}; twice that is {quadrupled}</p>

<button on:click="{() => count += 1}">+1</button>
```


## Мотивация

В [RFC 1](https://github.com/sveltejs/rfcs/blob/reactive-assignments/text/0001-reactive-assignments.md) мы ввели идею *реактивных присваиваний*, назначение локальных переменных компонента и код...

```js
count += 1;
```

...приведёт к обновлению компонента.

Как косвенное следствие этого изменения, мы можем избавиться от всех паттернов, связанных с компонентами Svelte 2, значительно упростив компилятор и код приложения пользователя. Но это также означает избавление от [вычисляемых свойств](https://svelte.technology/guide#computed-properties), которые являются мощным и удобным механизмом реактивности:

```html
<p>Twice {count} is {doubled}; twice that is {quadrupled}</p>

<button on:click="{() => count += 1}">+1</button>

<script>
  export default {
    data() {
      return { count: 1 };
    },

    computed: {
      doubled: ({ count }) => count * 2,
      quadrupled: ({ doubled }) => doubled * 2
    }
  };
</script>
```

Полезная вещь в вычисляемых свойствах заключается в том, что они пересчитываются только при изменении их входных данных, что позволяет избежать частой проблемы снижения производительности, которая затрагивает некоторые фреймворки, в которых производные значения должны пересчитываться при каждом рендеринге. В отличие от некоторых других фреймворков, которые реализуют вычисляемые свойства, компилятор может строить граф зависимостей вычисляемых свойств во время *компиляции*, позволяя ему топологически сортировать их и генерировать высокоэффективный код, которому не нужен оверхед в виде отслеживания зависимостей в *рантайме*.

Изначально в RFC 1 не раскрыта тема потери вычисляемых свойств, мы вроде бы можем просто заменить их функциями:

```html
<script>
  let count = 1;
  const doubled = () => count * 2;
  const quadrupled = () => doubled() * 2;
</script>

<p>Twice {count} is {doubled()}; twice that is {quadrupled()}</p>

<button on:click="{() => count += 1}">+1</button>
```

Но в этом случае `doubled` должен вызываться дважды (один раз напрямую, один раз в `quadrupled`). Кроме того, мы должны проследить, какие значения читаются при вызове `doubled` и `quadrupled`, чтобы мы знали, когда нам нужно обновить их; Можно, конечно, плюнуть на всю эту оптимизацию  и вызывать эти функции всякий раз, когда *что-нибудь* изменяется. В более реалистичных сценариях это приводит к гораздо большому количеству дополнительной работы относительно Svelte 2.

Единственный способ избежать этой работы — использовать [Весьма Умный Компилятор](http://wiki.c2.com/?SufficientlySmartCompiler). Нам явно нужна альтернатива.

## Подробнее о дизайне

В статье [Что такое Реактивное Програмиирование?](Http://paulstovell.com/blog/reactive-programming) Пол Стовелл вводит понятие 'destiny оператора':

```
var a = 10;
var b <= a + 1;
a = 20;
Assert.AreEqual(21, b);
```

Если бы мы могли использовать 'destiny оператор' в компонентах, компилятор Svelte 3 мог бы делать то же, что и с вычисленными свойствами в Svelte 2 — обновлять `b` всякий раз, когда изменяется `a`.

К сожалению, мы не можем этого сделать, потому что получится невалидный JavaScript. А по многим причинам важно, чтобы всё, что находится внутри блока `<script>` компонента, было валидным JS. Есть ли фрагмент синтаксиса, который мы могли бы использовать вместо него? К счастью, есть — *label* или по-русски *метка*:

```js
let a = 10;
let b;

$: b = a + 1;
```

Такое выражение сообщает компилятору: 'запусти выражение `b = a + 1` всякий раз, когда `a` изменяется'.

Надо признать, что это выглядит *странно*. Помимо незнакомых меток (для большинства из нас), мы привыкли к операторам, работающим по порядку сверху вниз.

Но это не так странно, как может показаться на первый взгляд. *Объявления* не запускаются по порядку. Класс может расширять конструктор функции, который будет определён позже. Если вам захочется, вы можете свободно размещать экспорты в верхней части модуля, а импорты в нижней части. В этом свете `$: b = a + 1` является просто **объявлением равентсва** между `b` и выражением `a + 1`, а не выражением как таковым.

Сама концепция не нова — создатели фреймворков изобрели всевозможные способы приблизится к 'destiny оператору'. `Computed` функция и декоратор MobX, RxJS Observables и вычисляемые свойства в Svelte и Vue — всё это связанные идеи. Основное отличие предлагаемого подхода заключается в том, что он синтаксически намного легче и зависит от отслеживания зависимостей во время компиляции, а не на засовывании всего этого в прокси с аксессорами(как пример).

Фактически, это похоже на [Observable](https://beta.observablehq.com/), платформу для реактивного програмиирования. В обоих случаях выражения выполняются многократно (но консервативно) в [топологическом порядке](https://beta.observablehq.com/@mbostock/how-observable-runs). Наиболее часто используемая аналогия — это электронная таблица, где ячейки с формулами автоматически остаются согласованными с ячейками, на которые они ссылаются, без необходимости обновления всего рабочего листа.

> Выбор символа `$`, который превзошёл другие символы в опросе, обусловлен тремя причинами: он визуально различим, прост в наборе и отражает использование префикса `$` в шаблонах для пометки значений как реактивных, это обсудим ниже.


### Механика реактивных объявлений

Во-первых, это *фактически* не объявления — мы просто помечаем операторы, которые должны периодически выполняться повторно. Вывод компилятора для примера в верхней части этого документа может выглядеть следующим образом:

```js
function init($$self, $$make_dirty) {
  let count = 1;
  let doubled;
  let quadrupled;

  function handle_click() {
    count += 1;
    $$make_dirty('count');
  }

  $$self.get = () => ({ count, doubled, quadrupled, handle_click });

  $$self.synchronize = $$dirty => {
    if ($$dirty.count) doubled = count * 2; $$dirty.doubled = true;
    if ($$dirty.doubled) quadrupled = doubled * 2; $$dirty.quadrupled = true;
  };
}
```

(Этот код просто для иллюстрации; он не является оптимальным.)

Следствием такого подхода является то, что мы можем обновить несколько вычисленных значений за один раз. Например, один из способов вычисления значений для диаграммы рассеяния SVG включает многократное повторение данных ...

```js
$: x_scale = get_scale([min_x, max_x], [0, width]);
$: y_scale = get_scale([min_y, max_y], [height, 0]);

$: min_x = Math.min(...points.map(p => p.x));
$: max_x = Math.max(...points.map(p => p.x));
$: min_y = Math.min(...points.map(p => p.y));
$: max_y = Math.max(...points.map(p => p.y));
```
...но мы могли бы сделать это более эффективно за один проход:

```js
$: x_scale = get_scale([min_x, max_x], [0, width]);
$: y_scale = get_scale([min_y, max_y], [height, 0]);

$: {
  min_x = Infinity; max_x = -Infinity; min_y = Infinity; max_y = -Infinity; // сброс

  points.forEach(point => {
    if (point.x < min_x) min_x = point.x;
    if (point.x > max_x) max_x = point.x;
    if (point.y < min_y) min_y = point.y;
    if (point.y > max_y) max_y = point.y;
  });
}
```


Другое следствие заключается в том, что появляются побочные эффекты — можно будет сделать даже так (`$: console.log(foo)`). Разумные люди могут согласиться, что это не стоит поощерять.


### Тайминг

Поскольку реактивные объявления упорядочены топологически, мы, вероятно, не хотим, чтобы они запускались сразу в исходном порядке после создания экземпляра.

Мы также не хотим запускать их сразу после каждого изменения. Пересчёт `foo` после обновления `bar`...

```js
// сложная функция для рассчета foo
$: foo = expensivelyRecompute(bar, baz);

function handleClick() {
  bar += 1;
  baz += 1;
}
```

... будет расточительным. Вместо этого все реактивные объявления должны обновляться за один раз, в начале цикла обновления компонента.

**Это подчёркивает ограничение** — речь не идёт об истинном 'destiny операторе', в котором промежуточное значение `foo` *могло* бы быть всегда доступно, если бы вы могли получить к нему доступ сразу после установки `bar`. Реактивные объявления *в конечном итоге* согласуются с их входными данными. Это важная вещь для чёткой коммуникации.

Это также поднимает вопрос о том, что должно произойти, если входные данные реактивного объявления обновляются в обработчике `beforeUpdate`, сразу после того, как произошла синхронизация.


### Значения только для чтения

В Svelte 2 вычисляемые свойства доступны только для чтения — попытка записи в них приводит к ошибке, правда только во время выполнения и только в режиме разработки. С этим предложением мы можем добиться большего: идентифицируя вычисляемые значения, мы можем рассматривать любые присвоения им (например, в обработчике событий) как недопустимые и выдавать предупреждение во время компиляции или (🐃) ошибку.


### Реактивные хранилища

В [RFC 2](https://github.com/sveltejs/rfcs/blob/svelte-observables/text/0002-observables.md) было представлено предложение по реактивным хранилищам.


Вкратце, идея заключается в том, что реактивное хранилище предоставляет метод `subscribe`, который можно использовать для отслеживания значения во времени; *writable* хранилища также предоставляют такие методы, как `set` и `update`. Это позволяет хранить состояние приложения вне дерева компонентов, где это уместно. Внутри шаблонов на хранилища можно ссылаться с префиксом `$`, который передаёт их значение:

```html
<script>
  import { todos, user } from './stores.js';
</script>

<h1>Hello {$user.name}!</h1>

{#each $todos as todo}
  <p>{todo.description}</p>
{/each}
```

Одним из ограничений реактивных хранилищ является то, что их трудно смешивать с локальным состоянием компонента. Например, если бы мы хотели отфильтровать список этих задач, мы не можем просто сделать производное хранилище, которое использовало бы локальную переменную для фильтра — 

```html
<script>
  import { derive } from 'svelte/store';
  import { todos, user } from './stores.js';

  let hideDone = false;
  const filtered = derive(todos, t => hideDone ? !t.done : true);
</script>

<h1>Hello {$user.name}!</h1>

<label>
  <input type=checkbox bind:checked={hideDone}>
  hide done
</label>

{#each $filtered as todo}
  <p>{todo.description}</p>
{/each}
```

— потому что `filtered` не может знать, когда изменяется `hideDone`. Вместо этого нам нужно создать новое хранилище:

```diff
<script>
-  import { derive } from 'svelte/store';
+  import { writable, derive } from 'svelte/store';
  import { todos, user } from './stores.js';

-  let hideDone = false;
-  const filtered = derive(todos, t => hideDone ? !t.done : true);
+  const hideDone = writable(false);
+  const filtered = derive([todos, hideDone], ([t, hideDone]) => hideDone ? !t.done : true);
</script>

<h1>Hello {$user.name}!</h1>

<label>
-  <input type=checkbox bind:checked={hideDone}>
+  <input type=checkbox checked={$hideDone} on:change="{e => hideDone.set(e.target.checked)}">
  hide done
</label>

{#each $filtered as todo}
  <p>{todo.description}</p>
{/each}
```

Реактивные объявления предлагают альтернативу, можно сделать такую же обработку значений с префиксом `$`:

```diff
<script>
  import { derive } from 'svelte/store';
  import { todos, user } from './stores.js';

  let hideDone = false;
-  const filtered = derive(todos, t => hideDone ? !t.done : true);
+  let filtered;
+  $: filtered = $todos.filter(t => hideDone ? !t.done : true);
</script>

<h1>Hello {$user.name}!</h1>

<label>
  <input type=checkbox bind:checked={hideDone}>
  hide done
</label>

-{#each $filtered as todo}
+{#each filtered as todo}
  <p>{todo.description}</p>
{/each}
```

Очевидная проблема тут заключается в том, что `$todos` нигде не определён в `<script>`, что потенциально может сбить с толку людей и редакторы кода. Это возможно решить с помощью документации и правилами линтеров.


## Как мы будем этому учить

Это не должно быть первым, с чем люди сталкиваются при изучении Svelte — удивительно, но многие люди 'соскакивают', прежде чем успеют вникнуть в ценность данного предложения. Вместо этого, можно сначала расказать как это сделать на ванильном JavaScript — т.е. вручную прописывать все обновления в функции `beforeUpdate`, после этого концепция данного предложения(а теперь давайте, компилятор сделает это за нас, только более эффективно!) уже будет более понятна.

При обсуждении реактивного программирования полезно обратиться и к существующим реализациям идеи, включая электронные таблицы.

## Недостатки

Многие люди, особенно те, кто проповедует чистый синтаксис JavaScript, прочитав это предложение, не смогут его принять.

Мы не должны стремиться переубеждать людей, чьё мнение уже сформировано. Справедливо признать, что это предложение понравится людям и улучшит (по общему признанию) кривую обучения для Svelte 3. Но может быть и так, что 'стоимость' добавления этой функции превысит потенциальные выгоды. Единственный способ узнать это — оценить реакцию людей на этот RFC. (До настоящего времени ответ был обнадёживающим, и большая часть проблем была сосредоточена на том, как данное предложение будет воспринятр людьми вне существующего сообщества Svelte.)

Элементы, которые могут быть особенно сложными для понимания, — это:
 
* то что реактивные объявления не запускаются при инициализации (хотя мы можем это изменить)
* то что реактивные объявления запускаются не сразу после изменения их входных данных, а скорее как часть цикла обновления
* использование префикса `$` для вывода данных из реактивных хранилищ

Нам также нужен продуманный ответ на вопрос о том, что должно произойти, когда входные данные переназначаются во время `beforeUpdate`.


## Альтернативы

Альтернатива 'оставить как есть' состоит в том, чтобы полагаться на вызовы функций — т.е. делать их зависимости явными либо пытаться их отслеживать. Поскольку 'Весьма Умный Компилятор' пока недостижим — это приведёт к значительным вычислительным затратам.

Или мы могли бы рассчитывать на то, что пользователи сами пересчитают значения в `beforeUpdate`. Это неэргономично и может привести к ненужной работе (пересчёт значений, если входные данные не изменились) или к ошибкам (если, наоборот, данные изменятся, а значения не пересчитаются).

Некоторые люди предлагают вместо этого использовать магические функции, превращая вызовы этих функций в код, который мы уже видели:

```js
import { compute } from 'svelte';

let a = 1;
let b = compute(() => a * 2);
```

Я лично нахожу это очень запутанным. Поскольку `compute` — это просто функция, я ожидаю от неё, что смогу вызвать её в другой функции, каррировать, передать за пределы компонента и т.п. Практически ни одно из обычных действий, которые я могу сделать с обычной функцией, я не смогу сделать с этой магической функцией.

Последняя альтернативная возможность состоит в том, чтобы сделать все объявления свойствами класса (а не автономными переменными) и использовать прокси/аксессор для доступа к ним во время выполнения, типа MobX или ещё чего-то подобного...

```js
@observable class MyStuff {
  @observe a = 1;

  @computed get b() {
    return this.a + 1;
  }
}

const stuff = new MyStuff();
```

... но это требует значительного оверхеда и в целом менее эргономично.


## Нерешённые вопросы

Детали насчёт того, когда именно реактивные объявления должны быть синхронизированы, до сих пор обсуждаются — одно из предположений состоит в том, что это должно произойти *после* `beforeUpdate`.