---
title: Рендеринг на стороне сервера (SSR)
---


До сих пор мы обсуждали создание компонентов Svelte *на стороне клиента*, то есть в браузере. Но вы также можете рендерить компоненты Svelte в Node.js. Это уменьшит 'время до появления контента', т.е. приложение начнёт отображаться в браузере немного раньше, пока страница всё ещё загружается и JavaScript скрипты ещё не начали свою работу. Кроме того, без серверного рендеринга практически не сделать качественной SEO оптимизации. Наконец, он может быть полезен для людей, использующих старые браузеры, которые по какой-либо причине не могут или не хотят использовать ваш JavaScript.


### Использование компилятора

При использовании компилятора Svelte либо напрямую, либо через плагин сборщика вроде [rollup-plugin-svelte](https://github.com/rollup/rollup-plugin-svelte) или [svelte-loader](https://github.com/sveltejs/svelte-loader), вы можете указать ему создавать серверные компоненты, передав ему опцию `generate: 'ssr'` option:

```js
const { js } = svelte.compile(source, {
	generate: 'ssr' // в отличие от "dom", по умолчанию
});
```


### Регистрация Svelte

В качестве альтернативы, простой способ использования рендерера на стороне сервера - это *зарегистрировать* его:

```js
require('svelte/register.js');
```

После этого вы сможете подключать ваши компоненты при помощи команды `require`:

```js
const Thing = require('./components/Thing.html');
```

Если вы предпочитаете использовать другое расширение файла, используйте следующий параметр:

```js
require('svelte/register.js')({
	extensions: ['.svelte']
});
```


### Серверное API

Компоненты имеют несколько другой API в Node.js - вместо того, чтобы быть конструктором, который можно было бы вызвать с ключевым словом `new`, компонент представляет собой объект с методом `render(data, options)`:

```js
require('svelte/register.js');
const Thing = require('./components/Thing.html');

const props = { answer: 42 };
const { html, css, head } = Thing.render(props);
```

[Хуки жизненого цикла](guide#lifecycle-hooks) (кроме onDestroy ) *не будут* вызываться, потому что компонент никогда не 'монтируется'.

> Компилятор SSR создаст из ваших компонентов CommonJS модули, при этом операторы `import` и `export` преобразуются в их эквиваленты `require` и `module.exports`. Если ваши компоненты имеют внекомпонентные зависимости, то они также *должны* работать как модули CommonJS в Node. Если вы используете модули ES2015, мы рекомендуем модуль [`esm`](https://github.com/standard-things/esm) для их автоматической конвертации в тип CommonJS.



#### Отрисовка стилей

Вы можете извлечь любые [изолированые стили](guide#scoped-styles), которые используются компонентом или его дочерними элементами:

```js
const { css } = Thing.render(data);
```

Полученный `css` можно поместить в отдельный файл таблицы стилей или включить их прямо на странице внутри тега `<style>`. В любом из этих случаев, нужно убедиться, что компилятор для клиентской стороны повторно не включит эти же стили. Для этого в CLI нужно добавить флаг `--no-css`. А при использовании систем сборки с плагином, таким как  `rollup-plugin-svelte`, передайте ему опцию `css: false`.



#### Отрисовка элемента `<head>`

Если ваш компонент, или любой из его дочерних компонентов, используют [специальный элемент](guide#-head-tags) `<svelte:head>`, то вы можете получить его содержимое:

```js
const { head } = Thing.render(data);
```
